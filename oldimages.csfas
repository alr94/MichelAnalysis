////////////////////////////////////////////////////////////////////////////////
// Module used to select Michel electron events and reconstruct thier energy
// 
// Events are selected by clustering hits tagged as michel-like with a CNN
// 
// Hits for use in energy reconstruction are collected inside a cone based on 
// the initial michel-like hits used to select the event
////////////////////////////////////////////////////////////////////////////////

// Larsoft includes
#include "larsim/MCCheater/BackTrackerService.h"
#include "larsim/MCCheater/ParticleInventoryService.h"
#include "larsim/Simulation/LArG4Parameters.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/AnalysisBase/T0.h"
#include "larreco/Calorimetry/CalorimetryAlg.h"
#include "larreco/RecoAlg/PMAlg/Utilities.h"
#include "larreco/RecoAlg/ProjectionMatchingAlg.h"
#include "nusimdata/SimulationBase/MCParticle.h"
#include "lardata/ArtDataHelper/MVAReader.h"

// Art includes
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

// ROOT includes
#include "TH2F.h"
#include "TTree.h"

// CPP includes
#include <fstream>
#include <string>
#include <limits>

namespace MichelReco {
	
class MichelReco;

class MichelReco : public art::EDAnalyzer {
	
public:
	explicit MichelReco(fhicl::ParameterSet const & p);
	// The destructor generated by the compiler is fine for classes
	// without bare pointers or other resource use.

	// Plugins should not be copied or assigned.
	MichelReco(MichelReco const &) = delete;
	MichelReco(MichelReco &&) = delete;
	MichelReco & operator = (MichelReco const &) = delete;
	MichelReco & operator = (MichelReco &&) = delete;

	// Required functions.
	void analyze(art::Event const & e) override;

	// Selected optional functions
	void beginJob() override; 
	void endJob() override; 
	void beginRun(art::Run const & run) override; 
	void reconfigure(fhicl::ParameterSet const & p); 

	//////////////// My function declarations //////////////// 
	
	calo::CalorimetryAlg fCaloAlg;
	pma::ProjectionMatchingAlg fPMAlg;
	
	std::unordered_map<int, const simb::MCParticle*> BuildParticleMap(
		art::Event const & evt);

	bool InsideFidVol(double pos[3], geo::Geometry const & geom);
	
	void GetProjections2D(TVector3 position_tvector, double position_array[3], 
		double (& position_array_2d)[3][2], const geo::Geometry & geom);

	void ResetCharge();
	
	void IntegrateEnergy(int view, 
		std::unordered_map<size_t, std::tuple<art::Ptr<recob::Hit>, bool, double>> 
			(& energyHits)[3]);

	void SumHits (int view, 
		std::unordered_map<size_t, std::tuple<art::Ptr<recob::Hit>, bool, double>> 
			energyHits[3]);
	
	int CombineViews(int view);
	
	bool HitCloseToVertex(double radius, double end2D[3][2],recob::Hit hit);
	
	int FindMichelsInTruth(geo::Geometry const & geom,
		std::unordered_map<int, const simb::MCParticle*> particleMap);
	
	bool IsMuonDecaying(simb::MCParticle particle, 
		std::unordered_map<int, const simb::MCParticle*> particleMap);
	
	bool HitsAreMichel(
		std::unordered_map<size_t, std::tuple<art::Ptr<recob::Hit>, bool, double>> 
			energyHits,
		int & michelTrackID);

	bool HitIsMichel(art::Ptr<recob::Hit> hit, int michelTrackID);
	
	double GetTrueMichelEnergy(int michelTrackID);
	
	void CollectMichelHits(double vertex[3], double vertex2D[3][2], 
		recob::Track track, 
		std::unordered_map<size_t,std::tuple<art::Ptr<recob::Hit>, bool, double>> 
			(& energyHits)[3],
		anab::MVAReader<recob::Hit, 4> hitResults,
		std::vector<art::Ptr<recob::Hit>> allHits,
		geo::Geometry const & geom);

	bool HitUsed(
		std::unordered_map<size_t, std::tuple<art::Ptr<recob::Hit>, bool, double>> 
			energyHits[3],
		size_t h, recob::Hit hit);
	
	bool EventSelection(
		std::unordered_map<size_t, std::tuple<art::Ptr<recob::Hit>, bool, double>> 
			energyHitsStart[3], 
		std::unordered_map<size_t, std::tuple<art::Ptr<recob::Hit>, bool, double>> 
			energyHitsEnd[3], 
		bool & startSelected, bool & endSelected);
	
	void CollectEnergyHits(double vertex[3], double vertex2D[3][2], 
		std::vector<std::vector<double>> projectedDirection,
		std::unordered_map<size_t, std::tuple<art::Ptr<recob::Hit>, bool, double>> 
			(& energyHits)[3],
		anab::MVAReader<recob::Hit, 4> hitResults, 
		std::vector<recob::Track> tracks,
		geo::Geometry const & geom);
	
	bool CloseToTrack(recob::Hit const & hit, 
		std::vector<recob::Track> tracks, geo::Geometry const & geom);

	bool HitInsideAngle(recob::Hit hit, geo::Geometry const & geom, 
		double vertex[3], double vertex2D[3][2], 
		std::vector<double> directionVec);
	
	std::vector<std::vector<double>> ProjectHits(double vertex[3], 
		double vertex2D[3][2],
		std::unordered_map<size_t, std::tuple<art::Ptr<recob::Hit>, bool, double>> 
			energyHits[3], 
		geo::Geometry const & geom);

	int TrackMatching( int trackIndex, 
		art::FindManyP<recob::Hit> hitsFromTracks );
	
	double HitToEnergy(art::Ptr<recob::Hit> hit);

	double TrueT0 (int bestTrackId); 

	void FillWithMax(TH2F * hist, Int_t bin, double weight);

	//////////// End of my function declarations //////////////

private:
	// art parameters
	art::InputTag fTrackModuleLabel;
	art::InputTag fNNetModuleLabel;
	art::InputTag fParticleModuleLabel;

	// Calorimetry algorithms helper
	Double_t fElectronsToMeV;

	// For naming events
	int fEvNumber;

	// Geometry parameters
	int fBestview;
	double fFidVolCut;

	// map to trackIDs to make the michel search in truth much faster
	// TODO: Check if this comment has lost a parameter

	// Event selection algorithm parameters
	double fRadiusThreshSelect;
	unsigned int fNumberThreshold;
	double fCNNThreshSelect;

	// Timing data for applying lifetime and recombination corrections
	double fTrueT0;
	double fT0;
	bool fHasT0;

	// hit coutning for energy reco algorithm 
	Int_t fNSelectHits;

	// Hit data
	double fHitTrueEnergy;
	double fHitRecoEnergy;
	
	// TTree for checking that the reco and true energy comparisons make sense
	TTree * fHitTree;
	
};

MichelReco::MichelReco(fhicl::ParameterSet const & p)
	: 
	EDAnalyzer(p), fCaloAlg (p.get<fhicl::ParameterSet>("CalorimetryAlg")),
	fPMAlg (p.get<fhicl::ParameterSet>("PMAlg")) {

	reconfigure(p);

}

void MichelReco::beginJob() {

	art::ServiceHandle<art::TFileService> tfs;

	fHitTree = tfs->make<TTree>("hit", "Hit reco and true info");
	fHitTree->Branch("fHitTrueEnergy", &fHitTrueEnergy, "fHitTrueEnergy/D");
	fHitTree->Branch("fHitRecoEnergy", &fHitRecoEnergy, "fHitRecoEnergy/D");

}

void MichelReco::endJob() { }

void MichelReco::beginRun(art::Run const &) {

	art::ServiceHandle<sim::LArG4Parameters> larParameters;
	fElectronsToMeV = 1000. / larParameters->GeVToElectrons();

}

void MichelReco::analyze(art::Event const & evt) {
	art::ServiceHandle<art::TFileService> tfs;
	
	// For naming conventions later
	fEvNumber = evt.id().event();

	// load detector geometry and back tracker once at start
	auto const & geom = *art::ServiceHandle<geo::Geometry>();

	// build map from trackID to particle to speed search in later functions
	std::unordered_map<int, const simb::MCParticle*> particleMap = 
		BuildParticleMap(evt);
	
	// get reconstructed tracks
	art::ValidHandle<std::vector<recob::Track>> trackHandle = 
		evt.getValidHandle<std::vector<recob::Track>>(fTrackModuleLabel);

	// get associated t0's
	const art::FindManyP<anab::T0> findTrackT0(trackHandle, 
			evt, fTrackModuleLabel);

	// CNN output for hits used to collect michel hits
	anab::MVAReader<recob::Hit, 4> hitResults(evt, fNNetModuleLabel);
	
	// get all hits from the event in the art ptr for to make it easier to handle
	// the hit tagging later 
	art::Handle<std::vector<recob::Hit> > hitCollector;
	std::vector<art::Ptr<recob::Hit> > allHits;
	if (evt.getByLabel("linecluster",hitCollector)) {
		art::fill_ptr_vector(allHits, hitCollector);
	}

	// Get the hits associated to tracks for the track matching algorithm
	art::FindManyP<recob::Hit> hitsFromTracks( trackHandle, evt, 
			fTrackModuleLabel );

	// Loop over tracks to select michel events around track end points
	auto const & tracks = *trackHandle;
	for (auto const & track : tracks) {

		// get track t0s and ignore any without a t0
		int track_index = &track - &tracks[0];

		// Get best track matched to this one
		int bestTrackID = TrackMatching(track_index, hitsFromTracks);
		auto const & t0s = findTrackT0.at(track_index);

		// Set t0 for t0 tagged tracks
		fT0 = std::numeric_limits<double>::max();
		fTrueT0 = TrueT0(bestTrackID);
		fHasT0 = false;
		if (t0s.size() > 0) { 
			fHasT0 = true;
			fT0 = - t0s[0]->Time() / 2.; 
		}

		// TODO: use true T0 for now if no measured T0 is provided
		if (!fHasT0) {	fT0 = fTrueT0; }
		if (fT0 > std::numeric_limits<double>::max() - 1.) { continue; }

		// get track end points
		double trackStart[3] = {track.Vertex().X(), track.Vertex().Y(),
			track.Vertex().Z()};
		double trackEnd[3] = {track.End().X(), track.End().Y(), track.End().Z()};
		
		// check if ends in fid volume
		bool startInFidVol = InsideFidVol(trackStart, geom);
		bool endInFidVol = InsideFidVol(trackEnd, geom);

		// keep tracks with ends in fid vol
		if (startInFidVol || endInFidVol) {
			
			// set of projections from track end to plane
			double trackStart2D[3][2]; double trackEnd2D[3][2];

			// all hits used in energy reco
			std::unordered_map<size_t, std::tuple<art::Ptr<recob::Hit>, bool, double>>
				energyHitsStart[3];
			std::unordered_map<size_t, std::tuple<art::Ptr<recob::Hit>, bool, double>>
				energyHitsEnd[3];
			
			// Collect energy hits at the start and end of the track if they are in
			// the fiducial volume      
			if (startInFidVol) {
				
				GetProjections2D(track.Vertex(), trackStart, trackStart2D, geom);
				
				CollectMichelHits(trackStart, trackStart2D, track, energyHitsStart, 
					hitResults, allHits, geom);

			}
			if (endInFidVol) {
				
				GetProjections2D(track.End(), trackEnd, trackEnd2D, geom);
				
				CollectMichelHits(trackEnd, trackEnd2D, track, energyHitsEnd, 
					hitResults, allHits, geom);

			}
			
			// select events based on collected hits
			bool startSelected = false; bool endSelected = false;
			bool eventSelected = EventSelection(energyHitsStart, energyHitsEnd, 
				startSelected, endSelected);
			
			// run energy reconstruction on selected events
			if (!eventSelected) { continue; }
			std::cout << "Event selected" << std::endl;

			// check if this event was a true michel electron depends on which end is
			// selected
			bool isTrueMichel(false);
			int michelTrackID = std::numeric_limits<int>::min();

			if (startSelected) {
				
				// check if the hits used in selection where from a true michel 
				isTrueMichel = HitsAreMichel(energyHitsStart[2], michelTrackID);
				if (isTrueMichel) {

					art::ServiceHandle<cheat::ParticleInventoryService> pis;
					auto const & trueMichel = pis->TrackIdToParticle(michelTrackID);
					double trueEnergy = trueMichel.E(0) * 1000;
					
					double ImageCenter[2] = {trackStart2D[2][0], trackStart2D[2][1]};
					double maxx(ImageCenter[0] + 60.), minx(ImageCenter[0] - 60.);
					double maxy(ImageCenter[1] + 60.), miny(ImageCenter[1] - 60.);
					
					std::ostringstream basename;
					basename << "event" << fEvNumber << "_trackindex" << track_index  <<
						"_energy" << trueEnergy << "_view" << fBestview << "_start";
						
					auto track_hist = tfs->make<TH2F>((basename.str() + "_track").c_str(),
							"Track Score", 2*(maxx-minx), minx, maxx, 2*(maxy-miny), miny, 
							maxy);

					auto em_hist = tfs->make<TH2F>((basename.str() + "_em").c_str(), 
							"em Score", 2*(maxx-minx), minx, maxx, 2*(maxy-miny), miny, 
							maxy);

					auto charge_hist = tfs->make<TH2F>(
							(basename.str() + "_charge").c_str(),
							"charge", 2*(maxx-minx), minx, maxx, 2*(maxy-miny), miny, maxy);

					auto reco_energy_hist = tfs->make<TH2F>(
							(basename.str() + "_recoenergy").c_str(),	"recoenergy", 
							2*(maxx-minx), minx, maxx, 2*(maxy-miny), miny, maxy);
					
					auto true_energy_hist = tfs->make<TH2F>(
							(basename.str() + "_trueenergy").c_str(),	"trueenergy", 
							2*(maxx-minx), minx, maxx, 2*(maxy-miny), miny, maxy);

					auto label_hist = tfs->make<TH2F>((basename.str() + "_label").c_str(),
							"label", 2*(maxx-minx), minx, maxx, 2*(maxy-miny), miny, maxy);	

					for (auto hit :  allHits) {

						fHitTrueEnergy = 0.; fHitRecoEnergy = 0.;

						if (hit->View() == 2 && 
								hit->WireID().TPC == geom.FindTPCAtPosition(trackStart).TPC) {

							auto const & hitLocation = pma::WireDriftToCm(hit->WireID().Wire,
								hit->PeakTime(), hit->View(), hit->WireID().TPC, 
								hit->WireID().Cryostat);

							std::array<float, 4> cnn_out = hitResults.getOutput(hit);
							
							Int_t bin = track_hist->Fill(hitLocation.X(), hitLocation.Y(),
									0.);
							
							FillWithMax(track_hist, bin, 
									cnn_out[hitResults.getIndex("track")]);

							FillWithMax(em_hist, bin, 
									cnn_out[hitResults.getIndex("em")]);

							charge_hist->Fill(hitLocation.X(), hitLocation.Y(), 
									hit->Integral());

							// TODO----> Calculate reco energy from hit charge and T0
							double hitAsEnergy = HitToEnergy(hit);
							reco_energy_hist->Fill(hitLocation.X(), hitLocation.Y(),
									hitAsEnergy);
							fHitRecoEnergy = hitAsEnergy;

							art::ServiceHandle<cheat::BackTrackerService> bt;
							auto const & hitIDEs = bt->HitToAvgSimIDEs(hit);
							for (auto const & hitIDE : hitIDEs) {
								true_energy_hist->Fill(hitLocation.X(), hitLocation.Y(), 
										hitIDE.energy);
								fHitTrueEnergy += hitIDE.energy;
							}

							fHitTree->Fill();

							if (HitIsMichel(hit, michelTrackID)) { 
								FillWithMax(label_hist, bin, 1.);
							}

						}

					}

				}

			}
			else {

				// check if the hits used in selection where from a true michel 
				isTrueMichel = HitsAreMichel(energyHitsEnd[2], michelTrackID);
				if (isTrueMichel) {

					art::ServiceHandle<cheat::ParticleInventoryService> pis;
					auto const & trueMichel = pis->TrackIdToParticle(michelTrackID);
					double trueEnergy = trueMichel.E(0) * 1000;

					double ImageCenter[2] = {trackEnd2D[2][0], trackEnd2D[2][1]};
					double maxx(ImageCenter[0] + 60.), minx(ImageCenter[0] - 60.);
					double maxy(ImageCenter[1] + 60.), miny(ImageCenter[1] - 60.);

					std::ostringstream basename;
					basename << "event" << fEvNumber << "_trackindex" << track_index << 
						"_energy" << trueEnergy << "_view" << fBestview << "_end";

					auto track_hist = tfs->make<TH2F>((basename.str() + "_track").c_str(),
							"Track Score", 2*(maxx-minx), minx, maxx, 2*(maxy-miny), miny, 
							maxy);	

					auto em_hist = tfs->make<TH2F>((basename.str() + "_em").c_str(), 
							"em Score", 2*(maxx-minx), minx, maxx, 2*(maxy-miny), miny, 
							maxy);	

					auto charge_hist = tfs->make<TH2F>(
							(basename.str() + "_charge").c_str(),
							"charge", 2*(maxx-minx), minx, maxx, 2*(maxy-miny), miny, maxy);

					auto reco_energy_hist = tfs->make<TH2F>(
							(basename.str() + "_recoenergy").c_str(),	"recoenergy", 
							2*(maxx-minx), minx, maxx, 2*(maxy-miny), miny, maxy);

					auto true_energy_hist = tfs->make<TH2F>(
							(basename.str() + "_trueenergy").c_str(),	"trueenergy", 
							2*(maxx-minx), minx, maxx, 2*(maxy-miny), miny, maxy);

					auto label_hist = tfs->make<TH2F>((basename.str() + "_label").c_str(),
							"label Score", 2*(maxx-minx), minx, maxx, 2*(maxy-miny), miny, 
							maxy);	

					for (auto hit : allHits) {

						if (hit->View() == 2 &&
								hit->WireID().TPC == geom.FindTPCAtPosition(trackEnd).TPC) {

							auto const & hitLocation = pma::WireDriftToCm(hit->WireID().Wire,
								hit->PeakTime(), hit->View(), hit->WireID().TPC, 
								hit->WireID().Cryostat);

							std::array<float, 4> cnn_out = hitResults.getOutput(hit);

							Int_t bin = track_hist->Fill(hitLocation.X(), hitLocation.Y(),
									0.);

							FillWithMax(track_hist, bin, 
									cnn_out[hitResults.getIndex("track")]);
							FillWithMax(em_hist, bin, 
									cnn_out[hitResults.getIndex("em")]);

							charge_hist->Fill(hitLocation.X(), hitLocation.Y(), 
									hit->Integral());

							// TODO----> Calculate reco energy from hit charge and T0
							double hitAsEnergy = HitToEnergy(hit);
							reco_energy_hist->Fill(hitLocation.X(), hitLocation.Y(),
									hitAsEnergy);

							art::ServiceHandle<cheat::BackTrackerService> bt;
							auto const & hitIDEs = bt->HitToAvgSimIDEs(hit);
							for (auto const & hitIDE : hitIDEs) {
								true_energy_hist->Fill(hitLocation.X(), hitLocation.Y(), 
										hitIDE.energy);
							}

							if (HitIsMichel(hit, michelTrackID)) { 
								FillWithMax(label_hist, bin, 1.); 
							}

						}

					}

				}

			} 

		}

	} // end of track loop

} // end of analyzer

void MichelReco::reconfigure(fhicl::ParameterSet const & p) {

	// art parameters
	fTrackModuleLabel = p.get<std::string>("TrackModuleLabel");
	fNNetModuleLabel = p.get<std::string>("NNetModuleLabel");
	fParticleModuleLabel = p.get<std::string>("ParticleModuleLabel");

	// Geometry parameters
	fBestview = p.get<int>("Bestview");  
	fFidVolCut = p.get<double>("FidVolCut");

	// Event selection algorithm parameters
	fRadiusThreshSelect = p.get<double>("MichelCloseHitRadius");
	fNumberThreshold = p.get<unsigned int>("CloseHitsThreshold");
	fCNNThreshSelect = p.get<double>("CNNThreshSelect");

	// outputs from energy reco algorithm 
	fEvNumber = std::numeric_limits<int>::min(); 
	fT0 = std::numeric_limits<double>::max();
	fTrueT0 = std::numeric_limits<double>::max();
	fHasT0 = false;
	
	// hit coutning for energy reco algorithm 
	fNSelectHits = -1;

	return;

}

////////////////////////////////////////////////////////////////////////////////
// Build a map from particle to particle ID to make finding daughters fast
////////////////////////////////////////////////////////////////////////////////
std::unordered_map<int, const simb::MCParticle*> MichelReco::BuildParticleMap(
		art::Event const & evt) {
	
	auto const & particles = 
		*evt.getValidHandle<std::vector<simb::MCParticle>>(fParticleModuleLabel);
	
	std::unordered_map<int, const simb::MCParticle*> particleMap;
	for (auto const & particle : particles) {
		particleMap[particle.TrackId()] = &particle;
	}
	
	return particleMap;

}
	
////////////////////////////////////////////////////////////////////////////////
// Checks if a given point is inside the fiducial volume
////////////////////////////////////////////////////////////////////////////////
bool MichelReco::InsideFidVol(double pos[3], geo::Geometry const & geom) {

	bool inside = false;
	
	geo::TPCID idtpc = geom.FindTPCAtPosition(pos);
	
	if (geom.HasTPC(idtpc)) {
		
		const geo::TPCGeo & tpcgeo = geom.GetElement(idtpc);
		
		double minx = tpcgeo.MinX(); double maxx = tpcgeo.MaxX();
		double miny = tpcgeo.MinY(); double maxy = tpcgeo.MaxY();
		double minz = tpcgeo.MinZ(); double maxz = tpcgeo.MaxZ();

		for (size_t cryo = 0; cryo < geom.Ncryostats(); cryo++) {
			const geo::CryostatGeo & cryostat = geom.Cryostat(cryo);
			for (size_t tpc = 0; tpc < cryostat.NTPC(); tpc++) {
				const geo::TPCGeo & tpcg = cryostat.TPC(tpc);
				if (tpcg.MinX() < minx) minx = tpcg.MinX();
				if (tpcg.MinY() < miny) miny = tpcg.MinY();
				if (tpcg.MinZ() < minz) minz = tpcg.MinZ();
				if (tpcg.MaxX() > maxx) maxx = tpcg.MaxX();
				if (tpcg.MaxY() > maxy) maxy = tpcg.MaxY();
				if (tpcg.MaxZ() > maxz) maxz = tpcg.MaxZ();
			}
		}

		double dista = fabs(minx - pos[0]); double distb = fabs(maxx - pos[0]);
		if ((pos[0] > minx) && (pos[0] < maxx) && (dista > fFidVolCut) && 
			(distb >  fFidVolCut)) { inside = true; }

		dista = fabs(miny - pos[1]); distb = fabs(maxy - pos[1]);
		if (inside && pos[1] > miny && pos[1] < maxy && dista > fFidVolCut && 
			distb > fFidVolCut) { inside = true; }
		else { inside = false; }
		
		dista = fabs(minz - pos[2]); distb = fabs(maxz - pos[2]);
		if (inside && pos[2] > minz && pos[2] < maxz && dista > fFidVolCut && 
			distb > fFidVolCut) { inside = true; }
		else { inside = false;  }

	}
	 
	return inside;

}

////////////////////////////////////////////////////////////////////////////////
// Gets all three projections from a 2D point to the wire planes 
////////////////////////////////////////////////////////////////////////////////
void MichelReco::GetProjections2D(TVector3 position_tvector, 
		double position_array[3], double (& position_array_2d)[3][2], 
		const geo::Geometry & geom) {
	
	for (int i = 0; i < 3; i++) {
		
		auto const & trackProjection = pma::GetProjectionToPlane( 
			position_tvector, i, geom.FindTPCAtPosition(position_array).TPC,
			geom.FindCryostatAtPosition(position_array));
		
		position_array_2d[i][0] = trackProjection.X();
		position_array_2d[i][1] = trackProjection.Y();

	}

}

////////////////////////////////////////////////////////////////////////////////
// checks if a hit is close to the 2D projection of a 3D track end
////////////////////////////////////////////////////////////////////////////////
bool MichelReco::HitCloseToVertex(double radius, double end2D[3][2], 
	recob::Hit hit) {

	auto const & hitLocation = pma::WireDriftToCm(hit.WireID().Wire,
		hit.PeakTime(), hit.View(), hit.WireID().TPC, hit.WireID().Cryostat);
	double deltaXToHit = hitLocation.X() - end2D[hit.View()][0];
	double deltaYToHit = hitLocation.Y() - end2D[hit.View()][1];
	double displacement = pow(pow(deltaXToHit,2) + pow(deltaYToHit,2), 0.5);
	
	return (displacement < radius);

}

////////////////////////////////////////////////////////////////////////////////
// checks if a vector of hits was most likely to come from a michel electron
////////////////////////////////////////////////////////////////////////////////
bool MichelReco::HitsAreMichel(
	std::unordered_map<size_t, std::tuple<art::Ptr<recob::Hit>, bool, double>> 
		energyHits,
	int & michelTrackID) {

	art::ServiceHandle<cheat::BackTrackerService> bt;
	art::ServiceHandle<cheat::ParticleInventoryService> pis;
	std::unordered_map<int,double> trkIDE;
	for (auto const & hitMap : energyHits) {
		auto const & hit = std::get<0>(hitMap.second);
		for (auto const & ide: bt->HitToTrackIDEs(hit)) {
			trkIDE[ide.trackID] += ide.energy;
		}
	}

	int best_id = 0; double tot_e = 0, max_e = 0;
	for (auto const & contrib : trkIDE) {
		tot_e += contrib.second;
		if (contrib.second <= max_e) {continue;}
		max_e = contrib.second;
		best_id = contrib.first;
	}
	
	const simb::MCParticle * mcParticle = 0;
	if (max_e > 0 && tot_e > 0) {
		if (best_id < 0) {
			best_id = -best_id;
		}
		mcParticle = pis->TrackIdToParticle_P(best_id);
		michelTrackID = best_id;
	}

	if (mcParticle != 0) {
		return abs(mcParticle->PdgCode()) == 11 && (mcParticle->Process() == 
			"Decay" || mcParticle->Process() == "muMinusCaptureAtRest"); 
	}
	else { return false; }

}

////////////////////////////////////////////////////////////////////////////////
// Check if a given hit is most likely to be from a michel
////////////////////////////////////////////////////////////////////////////////
bool MichelReco::HitIsMichel(art::Ptr<recob::Hit> hit, int michelTrackID) {

	art::ServiceHandle<cheat::BackTrackerService> bt;
	art::ServiceHandle<cheat::ParticleInventoryService> pis;
	
	double max_contrib = std::numeric_limits<int>::min(); 
	int best_id = std::numeric_limits<int>::min();
	for (auto const & ide : bt->HitToTrackIDEs(hit))
	{
		if (ide.energy <= max_contrib) { continue; }
		max_contrib = ide.energy;
		best_id = ide.trackID;		
	}

	const simb::MCParticle * mcParticle = 0;
	if (max_contrib < 0) { return false; }
	if (best_id < 0) { best_id = -best_id; }
	mcParticle = pis->TrackIdToParticle_P(best_id);

	if (mcParticle == 0) { return false; }
	if (mcParticle->TrackId() == michelTrackID) { return true; }
	return false;

}

////////////////////////////////////////////////////////////////////////////////
// checks if a muon has decayed by checking its daughters in truth 
////////////////////////////////////////////////////////////////////////////////
bool MichelReco::IsMuonDecaying(simb::MCParticle particle, 
	std::unordered_map<int, const simb::MCParticle*> particleMap) {

	bool hasElectron = false, hasNuMu = false, hasNuE = false;
	int pdg = abs(particle.PdgCode());
	if ((pdg ==13) && (particle.EndProcess() == "FastScintillation")) {
		
		unsigned int nSec = particle.NumberDaughters();
		for (size_t d = 0; d < nSec; ++d) {
			
			auto d_search = particleMap.find(particle.Daughter(d));
			if (d_search == particleMap.end()) {continue;}
				
			auto const & daughter = *((*d_search).second);
			int d_pdg = abs(daughter.PdgCode());
			if (d_pdg == 11) hasElectron = true;
			else if (d_pdg == 14) hasNuMu = true;
			else if (d_pdg == 12) hasNuE = true;

		}

	}

	return (hasElectron && hasNuMu && hasNuE);

}

////////////////////////////////////////////////////////////////////////////////
// loops through true particles to count the number of michel electrons
////////////////////////////////////////////////////////////////////////////////
int MichelReco::FindMichelsInTruth(geo::Geometry const & geom,
	std::unordered_map<int, const simb::MCParticle*> particleMap) {

	int count = 0;
	for (auto particleIterator : particleMap) {
		
		simb::MCParticle particle = *particleIterator.second;
		
		double mcEnd[3] = {particle.EndX(), particle.EndY(), particle.EndZ()};
		
		if (MichelReco::IsMuonDecaying(particle, particleMap) && 
			MichelReco::InsideFidVol(mcEnd, geom)) { count += 1; }

	}
	return count;
}

////////////////////////////////////////////////////////////////////////////////
// collects all "Michel-like" hits near a 2D vertex location in all views
////////////////////////////////////////////////////////////////////////////////
void MichelReco::CollectMichelHits(double vertex[3], double vertex2D[3][2], 
	recob::Track track, 
	std::unordered_map<size_t,std::tuple<art::Ptr<recob::Hit>, bool, double>> 
		(& energyHits)[3],
	anab::MVAReader<recob::Hit, 4> hitResults, 
	std::vector<art::Ptr<recob::Hit>> allHits,
	geo::Geometry const & geom) {
	
	for (auto const & hit : allHits) {

		int h = &hit - &allHits[0];
	
		if (hit->WireID().TPC != geom.FindTPCAtPosition(vertex).TPC) {continue;}
		
		std::array<float, 4> cnn_out = hitResults.getOutput(hit);
		if (cnn_out[hitResults.getIndex("michel")] < fCNNThreshSelect) { continue; }
			
		if (!MichelReco::HitCloseToVertex(fRadiusThreshSelect, vertex2D, *hit)) { 
			continue; 
		}

		energyHits[hit->View()][h] = std::make_tuple(hit, true, hit->Integral());

	}

}

////////////////////////////////////////////////////////////////////////////////
// makes sure no hitsa are duplicated in energy reconstruction
////////////////////////////////////////////////////////////////////////////////
bool MichelReco::HitUsed(
	std::unordered_map<size_t, std::tuple<art::Ptr<recob::Hit>, bool, double>> 
		energyHits[3],
	size_t h, recob::Hit hit) {

	bool hitUsed = true;
	
	auto d_search = energyHits[hit.View()].find(h);
	if (d_search == energyHits[hit.View()].end()) {hitUsed = false;}

	return hitUsed;

}

////////////////////////////////////////////////////////////////////////////////
// makes event selection decision based on the collected michel like hits  
////////////////////////////////////////////////////////////////////////////////
bool MichelReco::EventSelection(
	std::unordered_map<size_t, std::tuple<art::Ptr<recob::Hit>, bool, double>> 
		energyHitsStart[3], 
	std::unordered_map<size_t, std::tuple<art::Ptr<recob::Hit>, bool, double>> 
		energyHitsEnd[3], 
	bool & startSelected, bool & endSelected) {

	startSelected = (energyHitsStart[0].size() >= fNumberThreshold &&
		energyHitsStart[1].size() >= fNumberThreshold &&
		energyHitsStart[2].size() >= fNumberThreshold);
	
	endSelected = (energyHitsEnd[0].size() >= fNumberThreshold &&
		energyHitsEnd[1].size() >= fNumberThreshold &&
		energyHitsEnd[2].size() >= fNumberThreshold);
	
	bool eventSelected = ((startSelected || endSelected) && !(startSelected
		&& endSelected));

	return eventSelected;

}

////////////////////////////////////////////////////////////////////////////////
// Takes a hit and applies appropriate corrections to turn it into a 
// reconstructed energy
////////////////////////////////////////////////////////////////////////////////
double MichelReco::HitToEnergy(art::Ptr<recob::Hit> hit) {

	double energy = 0.;
	
	double lifetime_correction = fCaloAlg.LifetimeCorrection(hit->PeakTime(), 
			fT0);

	std::cout << lifetime_correction << std::endl;

	double lifetime_corrected_integral = hit->Integral() * lifetime_correction;

	double electrons = fCaloAlg.ElectronsFromADCArea(lifetime_corrected_integral,
			fBestview);

	energy = electrons * fElectronsToMeV;

	double recombination_factor = 0.69; // TODO: Make this a fcl

	energy /= recombination_factor;

	return energy;

}

////////////////////////////////////////////////////////////////////////////////
// Gets the true particle ID for a reconstructed track
////////////////////////////////////////////////////////////////////////////////
int MichelReco::TrackMatching( int trackIndex, 
		art::FindManyP<recob::Hit> hitsFromTracks ) {

	std::map<int,double> trackID_E;
	art::ServiceHandle<cheat::BackTrackerService> bt;

	for (size_t h = 0; h < hitsFromTracks.at(trackIndex).size(); ++h)
	{ 
		for (auto const & id : bt->HitToTrackIDEs(hitsFromTracks.at(trackIndex)[h]))
		{ 
			trackID_E[id.trackID] += id.energy;
		}
	}

	double max_e = 0.0; double tot_e = 0.0;
	int best_id = 0;
	for (std::map<int,double>::iterator it = trackID_E.begin(); 
			it != trackID_E.end(); ++it)
	{
		tot_e += it->second;
		if (it->second > max_e)
		{
			max_e = it->second;
			best_id = it->first;
		}
	}

	if ((max_e > 0.0) && (tot_e > 0.0)) { return best_id; }
	else { return std::numeric_limits<int>::min(); }

}

////////////////////////////////////////////////////////////////////////////////
// get the true t0 associated to a track in us, if not it just returns a big 
// defualt value
////////////////////////////////////////////////////////////////////////////////
double MichelReco::TrueT0 (int bestTrackId) {
	
	if 	(bestTrackId != std::numeric_limits<int>::min()) {
		
		art::ServiceHandle<cheat::ParticleInventoryService> pis;

		auto const & particle = pis->TrackIdToParticle(bestTrackId);

		return particle.T() / 1000.;

	}
	
	return std::numeric_limits<double>::max();

}

////////////////////////////////////////////////////////////////////////////////
// Fill bin with max of two values, used to make sure that the CNN results bins
// are not summed and so the CNN score that is ther largest in a given bin is 
// taken
////////////////////////////////////////////////////////////////////////////////
void MichelReco::FillWithMax(TH2F * hist, Int_t bin, double weight) {

	if (hist->GetBinContent(bin) < weight)	{ hist->SetBinContent(bin, weight); }

}

} // end of namespace

DEFINE_ART_MODULE(MichelReco::MichelReco)
